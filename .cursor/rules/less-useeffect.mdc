---
alwaysApply: true
---

# Avoid `useEffect` Pollution

Effects are an escape hatch from React—they let you sync with external systems like the DOM, network, or non-React widgets.

If there is no external system involved (for example, if you want to update a component’s state when some props or state change), you shouldn’t need an Effect.

Avoiding unnecessary Effects makes your code simpler, faster, and more reliable.

## How to remove unnecessary Effects

- **You don’t need Effects to transform data for rendering.**
- **You don’t need Effects to handle user events.**

## Updating state based on props or state

You have a component with `firstName` and `lastName` state. To keep `fullName` updated when either changes, you might think to add a `fullName` state and update it in an Effect.

```tsx
function Form() {
  const [firstName, setFirstName] = useState("Taylor");
  const [lastName, setLastName] = useState("Swift");

  // 🔴 BAD! Avoid: redundant state and unnecessary Effect
  const [fullName, setFullName] = useState("");
  useEffect(() => {
    setFullName(firstName + " " + lastName);
  }, [firstName, lastName]);
  // ...
}
```

This approach is inefficient, causing an initial render with stale `fullName`, then immediately re-renders with the updated value. Instead, remove the state and Effect:

```tsx
function Form() {
  const [firstName, setFirstName] = useState("Taylor");
  const [lastName, setLastName] = useState("Swift");
  // ✅ Good: calculated during rendering
  const fullName = firstName + " " + lastName;
  // ...
}
```

**IMPORTANT**: When something can be calculated from the existing props or state, **don’t put it in state**. Instead, calculate it during rendering.

## Caching expensive calculations

This component computes `visibleTodos` by taking the `todos` it receives by props and filtering them according to the `filter` prop. You might feel tempted to store the result in state and update it from an Effect:

```tsx
function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState("");

  // 🔴 BAD!Avoid: redundant state and unnecessary Effect
  const [visibleTodos, setVisibleTodos] = useState([]);
  useEffect(() => {
    setVisibleTodos(getFilteredTodos(todos, filter));
  }, [todos, filter]);

  // ...
}
```

Similar to the previous example, this is inefficient.

```tsx
function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState("");
  // ✅ This is fine if getFilteredTodos() is not slow.
  const visibleTodos = getFilteredTodos(todos, filter);
  // ...
}
```

**Note**: React Compiler can automatically memoize expensive calculations for you, eliminating the need for manual useMemo in many cases.

The function you or React Compiler wrap in useMemo runs during rendering, so this only works for pure calculations.

- A component must be pure, meaning:
  - It minds its own business. It should not change any objects or variables that existed before rendering.
  - Same inputs, same output. Given the same inputs, a component should always return the same JSX.
- Rendering can happen at any time, so components should not depend on each others’ rendering sequence.
- You should not mutate any of the inputs that your components use for rendering. That includes props, state, and context. To update the screen, “set” state instead of mutating preexisting objects.
- Strive to express your component’s logic in the JSX you return. When you need to “change things”, you’ll usually want to do it in an event handler. As a last resort, you can useEffect.

## Resetting all state when a prop changes

The `ProfilePage` gets a `userId` prop and has a `comment` state for input. But when switching profiles, the comment isn’t reset, so you might post on the wrong profile. To fix it, you might want to do this:

```tsx
export default function ProfilePage({ userId }) {
  const [comment, setComment] = useState("");

  // 🔴 BAD! Avoid: Resetting state on prop change in an Effect
  useEffect(() => {
    setComment("");
  }, [userId]);
  // ...
}
```

This is inefficient - `ProfilePage` first renders with stale data, then re-renders. It’s also messy, since you'd need to reset state in every nested component.

A better approach: treat each user’s profile as a separate one by giving it a unique `key`. Split the component and pass a `key` from the outer to the inner part.

```tsx
export default function ProfilePage({ userId }) {
  return <Profile userId={userId} key={userId} />;
}

function Profile({ userId }) {
  // ✅ GOOD! This and any other state below will reset on key change automatically
  const [comment, setComment] = useState("");
  // ...
}
```

## Adjusting some state when a prop changes

Sometimes you only want to reset part of the state when a prop changes.

For example, this `List` component gets `items` as a prop and tracks the selected item in `selection`. You want to reset `selection` to `null` whenever `items` prop receives a different array:

```tsx
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  // 🔴 BAD! Avoid: Adjusting state on prop change in an Effect
  useEffect(() => {
    setSelection(null);
  }, [items]);
  // ...
}
```

This is also inefficient: when `items` change, `List` renders with stale `selection`, then an Effect triggers a second re-render, restarting this whole process again.

A better fix: remove the Effect and adjust the state directly during render.

```tsx
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  // Better: Adjust the state while rendering
  const [prevItems, setPrevItems] = useState(items);
  if (items !== prevItems) {
    setPrevItems(items);
    setSelection(null);
  }
  // ...
}
```

**Although this pattern is more efficient than an Effect, most components shouldn’t need it either.**

For example, instead of storing (and resetting) the selected item, you can store the selected item ID:

```tsx
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selectedId, setSelectedId] = useState(null);
  // ✅ BEST: Calculate everything during rendering
  const selection = items.find((item) => item.id === selectedId) ?? null;
  // ...
}
```

## Sharing logic between event handlers

You have a product page with two buttons (Buy and Checkout) that add the product to the cart. To avoid repeating `showNotification()` in both click handlers, you might be tempted to move it into an Effect.

```tsx
function ProductPage({ product, addToCart }) {
  // 🔴 BAD! Avoid: Event-specific logic inside an Effect
  useEffect(() => {
    if (product.isInCart) {
      showNotification(`Added ${product.name} to the shopping cart!`);
    }
  }, [product]);

  function handleBuyClick() {
    addToCart(product);
  }

  function handleCheckoutClick() {
    addToCart(product);
    navigateTo("/checkout");
  }
  // ...
}
```

This Effect is unnecessary and buggy (e.g., persistent notifications on refresh). When choosing between an Effect and an event handler, ask: "Why does this code need to run?" Effects are for logic that runs because the component is displayed. Event handlers are for logic triggered by user interaction. Here, the notification is a direct result of a button press, not page display.

Solution:

```tsx
function ProductPage({ product, addToCart }) {
  // ✅ Good: Event-specific logic is called from event handlers
  function buyProduct() {
    addToCart(product);
    showNotification(`Added ${product.name} to the shopping cart!`);
  }

  function handleBuyClick() {
    buyProduct();
  }

  function handleCheckoutClick() {
    buyProduct();
    navigateTo("/checkout");
  }
  // ...
}
```

## Chains of computations

DO NOT chain Effects that each adjust a piece of state based on other state

```tsx
function Game() {
  const [card, setCard] = useState(null);
  const [goldCardCount, setGoldCardCount] = useState(0);
  const [round, setRound] = useState(1);
  const [isGameOver, setIsGameOver] = useState(false);

  // 🔴 BAD! Avoid: Chains of Effects that adjust the state solely to trigger each other
  useEffect(() => {
    if (card !== null && card.gold) {
      setGoldCardCount(c => c + 1);
    }
  }, [card]);

  useEffect(() => {
    if (goldCardCount > 3) {
      setRound(r => r + 1)
      setGoldCardCount(0);
    }
  }, [goldCardCount]);

  useEffect(() => {
    if (round > 5) {
      setIsGameOver(true);
    }
  }, [round]);

  useEffect(() => {
    alert('Good game!');
  }, [isGameOver]);

  function handlePlaceCard(nextCard) {
    if (isGameOver) {
      throw Error('Game already ended.');
    } else {
      setCard(nextCard);
    }
  }

  // ...
```

This code has two issues.

First, it’s inefficient: each `set` causes a re-render, leading to multiple unnecessary renders (e.g. `setCard → render → setGoldCardCount → render → ...`).

Second, it’s fragile. If you add features like stepping through game history by setting past state, the Effect chain will run again and overwrite what you’re trying to show.

A better approach: compute what you can during render, and update state directly in the event handler:

```tsx
function Game() {
  const [card, setCard] = useState(null);
  const [goldCardCount, setGoldCardCount] = useState(0);
  const [round, setRound] = useState(1);

  // ✅ GOOD! Calculate what you can during rendering
  const isGameOver = round > 5;

  function handlePlaceCard(nextCard) {
    if (isGameOver) {
      throw Error('Game already ended.');
    }

    // ✅ GOOD! Calculate all the next state in the event handler
    setCard(nextCard);
    if (nextCard.gold) {
      if (goldCardCount <= 3) {
        setGoldCardCount(goldCardCount + 1);
      } else {
        setGoldCardCount(0);
        setRound(round + 1);
        if (round === 5) {
          alert('Good game!');
        }
      }
    }
  }

  // ...
```

**Keep in mind**: inside event handlers, state is a snapshot. So after setRound(round + 1), round still holds the old value.

## Initializing the application

Some logic should only run once when the app loads.

You might be tempted to place it in an Effect in the top-level component:

```tsx
function App() {
  // 🔴 BAD! Avoid: Effects with logic that should only ever run once
  useEffect(() => {
    loadDataFromLocalStorage();
    checkAuthToken();
  }, []);
  // ...
}
```

It runs twice in dev, which can cause issues (e.g. token invalidation). All components, even `App`, should handle remounts safely.

If logic must run once per app load, track it with a top-level flag:

```tsx
let didInit = false;

function App() {
  useEffect(() => {
    if (!didInit) {
      didInit = true;
      // ✅ GOOD! Only runs once per app load
      loadDataFromLocalStorage();
      checkAuthToken();
    }
  }, []);
  // ...
}
```

You can also run it during module initialization and before the app renders:

```tsx
if (typeof window !== "undefined") {
  // Check if we're running in the browser.
  // ✅ Only runs once per app load
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
```

## Notifying parent components about state changes

You’re building a `Toggle` with internal `isOn` state (`true` or `false`), toggled by click or drag. You expose an onChange prop and call it from an Effect to notify the parent when the internal state changes—but this leads to problems:

```tsx
function Toggle({ onChange }) {
  const [isOn, setIsOn] = useState(false);

  // 🔴 BAD! Avoid: The onChange handler runs too late
  useEffect(() => {
    onChange(isOn);
  }, [isOn, onChange]);

  function handleClick() {
    setIsOn(!isOn);
  }

  function handleDragEnd(e) {
    if (isCloserToRightEdge(e)) {
      setIsOn(true);
    } else {
      setIsOn(false);
    }
  }

  // ...
}
```

Like earlier, this is bad. `Toggle` updates its state, React re-renders, then the Effect runs and triggers `onChange`, causing another render. It’s better to handle both updates in one pass—remove the Effect and update both states in the event handler.

```tsx
function Toggle({ onChange }) {
  const [isOn, setIsOn] = useState(false);

  function updateToggle(nextIsOn) {
    // ✅ Good: Perform all updates during the event that caused them
    setIsOn(nextIsOn);
    onChange(nextIsOn);
  }

  function handleClick() {
    updateToggle(!isOn);
  }

  function handleDragEnd(e) {
    if (isCloserToRightEdge(e)) {
      updateToggle(true);
    } else {
      updateToggle(false);
    }
  }

  // ...
}
```

You might also be able to remove the state altogether, and instead receive isOn from the parent component:

```tsx
// ✅ Also good: the component is fully controlled by its parent
function Toggle({ isOn, onChange }) {
  function handleClick() {
    onChange(!isOn);
  }

  function handleDragEnd(e) {
    if (isCloserToRightEdge(e)) {
      onChange(true);
    } else {
      onChange(false);
    }
  }

  // ...
}
```

Whenever you try to keep two different state variables synchronized, try lifting state up instead!

## Passing data to the parent

This Child component fetches some data and then passes it to the Parent component in an Effect:

```tsx
function Parent() {
  const [data, setData] = useState(null);
  // ...
  return <Child onFetched={setData} />;
}

function Child({ onFetched }) {
  const data = useSomeAPI();
  // 🔴 BAD! Avoid: Passing data to the parent in an Effect
  useEffect(() => {
    if (data) {
      onFetched(data);
    }
  }, [onFetched, data]);
  // ...
}
```

In React, data flows from parent to child. If something’s wrong on screen, you can trace it by going up the component tree. But if a child updates parent state in an Effect, that flow becomes hard to follow. If both need the same data, the parent should fetch it and pass it down:

```tsx
function Parent() {
  const data = useSomeAPI();
  // ...
  // ✅ Good: Passing data down to the child
  return <Child data={data} />;
}

function Child({ data }) {
  // ...
}
```

## Subscribing to an external store

Sometimes components need to subscribe to external data—like from a library or browser API—that React doesn’t track. In such cases, you manually subscribe using an Effect. For example:

```tsx
function useOnlineStatus() {
  // Not ideal: Manual store subscription in an Effect
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function updateState() {
      setIsOnline(navigator.onLine);
    }

    updateState();

    window.addEventListener("online", updateState);
    window.addEventListener("offline", updateState);
    return () => {
      window.removeEventListener("online", updateState);
      window.removeEventListener("offline", updateState);
    };
  }, []);
  return isOnline;
}

function ChatIndicator() {
  const isOnline = useOnlineStatus();
  // ...
}
```

This component subscribes to external data (`navigator.onLine`). Since this API isn’t available on the server, the initial state is set to `true`. When the value changes in the browser, the component updates its state.

While using an Effect here is common, React provides a better tool: `useSyncExternalStore`. Replace the Effect with that Hook:

```tsx
function subscribe(callback) {
  window.addEventListener("online", callback);
  window.addEventListener("offline", callback);
  return () => {
    window.removeEventListener("online", callback);
    window.removeEventListener("offline", callback);
  };
}

function useOnlineStatus() {
  // ✅ Good: Subscribing to an external store with a built-in Hook
  return useSyncExternalStore(
    subscribe, // React won't resubscribe for as long as you pass the same function
    () => navigator.onLine, // How to get the value on the client
    () => true // How to get the value on the server
  );
}

function ChatIndicator() {
  const isOnline = useOnlineStatus();
  // ...
}
```

## Fetching data

Many apps use Effects to kick off data fetching. It is quite common to write a data fetching Effect like this:

```tsx
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  const [page, setPage] = useState(1);

  useEffect(() => {
    // 🔴 BAD! Avoid: Fetching without cleanup logic
    fetchResults(query, page).then((json) => {
      setResults(json);
    });
  }, [query, page]);

  function handleNextPageClick() {
    setPage(page + 1);
  }
  // ...
}
```

You don’t need to move this fetch into an event handler.

That might seem inconsistent with earlier examples, but here the fetch isn’t tied to typing—it’s tied to `query` and `page`, which can come from the URL or browser navigation.

While the component is visible, you want results to stay in sync with the current `query` and `page`, so an Effect makes sense.

But there's a bug: if you type "hello" quickly, multiple fetches start (`"h"`, `"he"`, etc.), and their responses can arrive out of order. For example, the `"hell"` result might overwrite `"hello"`—a classic race condition.

To fix it, add a cleanup function to ignore stale responses:

```tsx
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  const [page, setPage] = useState(1);
  useEffect(() => {
    let ignore = false;
    fetchResults(query, page).then((json) => {
      if (!ignore) {
        setResults(json);
      }
    });
    return () => {
      ignore = true;
    };
  }, [query, page]);

  function handleNextPageClick() {
    setPage(page + 1);
  }
  // ...
}
```
